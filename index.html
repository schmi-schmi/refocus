<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Time to Refocus!</title>
    <link rel="stylesheet" href="./css/styles.css">
</head>
<body>
    <div class="container">
        <!-- Welcome header -->
        <div class="welcome-header">
            ‚ú® Welcome back! Ready to refocus your energy? ‚ú®
        </div>

        <!-- Main content area -->
        <div class="main-content">
            <!-- Left sidebar -->
            <div class="left-sidebar">
                <!-- Todo section -->
                <div class="todo-section">
                    <h3>Daily Intentions</h3>
                    
                    <!-- Day tabs -->
                    <div class="day-tabs">
                        <button class="day-tab" data-day="monday">Mon</button>
                        <button class="day-tab" data-day="tuesday">Tue</button>
                        <button class="day-tab" data-day="wednesday">Wed</button>
                        <button class="day-tab" data-day="thursday">Thu</button>
                        <button class="day-tab" data-day="friday">Fri</button>
                        <button class="day-tab" data-day="saturday">Sat</button>
                        <button class="day-tab" data-day="sunday">Sun</button>
                    </div>
                    
                    <!-- Todo list container -->
                    <div class="todo-list-container">
                        <div class="todo-list" id="todo-list">
                            <!-- Todos will be dynamically loaded here -->
                        </div>
                        
                        <!-- No items message -->
                        <div class="no-items" id="no-items" style="display: none;">
                            No items
                        </div>
                        
                        <!-- Add new todo button -->
                        <button class="add-todo-btn" id="add-todo-btn">
                            <span>+</span>
                        </button>
                    </div>
                </div>

                <!-- Rant space -->
                <div class="rant-space">
                    <h3>üí≠ Mind Dump</h3>
                    <textarea placeholder="What's on your mind? Let it all out here... sometimes we just need to write it down to feel better."></textarea>
                </div>
            </div>

            <!-- Carousel section -->
            <div class="carousel-section">
                <div class="carousel-container">
                    <div class="carousel-track" id="carousel-track">
                        <!-- Slides will be dynamically generated -->
                    </div>
                    <div class="slide-counter">
                        <span id="current-num">1</span> / <span id="total-num">9</span>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Storage utilities (frontend-only, no backend)
        const STORAGE_KEY = 'refocus_todos_v1';

        function getIsoWeekInfo(date) {
            const target = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate()));
            const dayNum = target.getUTCDay() || 7;
            target.setUTCDate(target.getUTCDate() + 4 - dayNum);
            const yearStart = new Date(Date.UTC(target.getUTCFullYear(), 0, 1));
            const weekNo = Math.ceil(((target - yearStart) / 86400000 + 1) / 7);
            const isoYear = target.getUTCFullYear();
            return { isoYear, isoWeek: weekNo };
        }

        function getCurrentWeekKey() {
            const { isoYear, isoWeek } = getIsoWeekInfo(new Date());
            return `${isoYear}-W${String(isoWeek).padStart(2, '0')}`;
        }

        function readStorage() {
            try {
                const raw = localStorage.getItem(STORAGE_KEY);
                if (!raw) return { lastResetWeek: null, lastId: 0, todos: [] };
                const parsed = JSON.parse(raw);
                if (!parsed || typeof parsed !== 'object') return { lastResetWeek: null, lastId: 0, todos: [] };
                if (!Array.isArray(parsed.todos)) parsed.todos = [];
                return parsed;
            } catch (_) {
                return { lastResetWeek: null, lastId: 0, todos: [] };
            }
        }

        function writeStorage(data) {
            localStorage.setItem(STORAGE_KEY, JSON.stringify(data));
        }

        function checkWeeklyReset() {
            const data = readStorage();
            const currentWeek = getCurrentWeekKey();
            if (data.lastResetWeek !== currentWeek) {
                data.lastResetWeek = currentWeek;
                data.lastId = 0;
                data.todos = [];
                writeStorage(data);
            }
        }

        function getTodosForDay(day) {
            const data = readStorage();
            return data.todos
                .filter(t => t.day_of_week === day && !t.deleted)
                .sort((a, b) => {
                    if (Number(a.completed) !== Number(b.completed)) {
                        return Number(a.completed) - Number(b.completed);
                    }
                    return new Date(a.created_at) - new Date(b.created_at);
                });
        }

        // getAllTodos removed (unused)

        function addTodo(text, day) {
            const data = readStorage();
            const now = new Date().toISOString();
            const id = (data.lastId || 0) + 1;
            const newTodo = {
                id,
                text: String(text),
                day_of_week: String(day),
                completed: false,
                deleted: false,
                created_at: now,
                updated_at: now
            };
            data.todos.push(newTodo);
            data.lastId = id;
            writeStorage(data);
            return newTodo;
        }

        function updateTodo(id, fields) {
            const data = readStorage();
            const idx = data.todos.findIndex(t => String(t.id) === String(id) && !t.deleted);
            if (idx === -1) return null;
            const now = new Date().toISOString();
            data.todos[idx] = { ...data.todos[idx], ...fields, updated_at: now };
            writeStorage(data);
            return data.todos[idx];
        }

        function softDeleteTodo(id) {
            return updateTodo(id, { deleted: true });
        }

        // Todo functionality
        class TodoApp {
            constructor() {
                this.currentDay = this.getCurrentDay();
                this.todos = [];
                this.editingId = null;
                
                this.init();
            }
            
            getCurrentDay() {
                const days = ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday'];
                return days[new Date().getDay()];
            }
            
            init() {
                checkWeeklyReset();
                this.setupEventListeners();
                this.loadTodos(this.currentDay);
                this.setActiveTab(this.currentDay);
            }
            
            setupEventListeners() {
                // Day tab clicks
                document.querySelectorAll('.day-tab').forEach(tab => {
                    tab.addEventListener('click', (e) => {
                        const day = e.target.dataset.day;
                        this.currentDay = day;
                        this.setActiveTab(day);
                        this.loadTodos(day);
                    });
                });
                
                // Add todo button
                document.getElementById('add-todo-btn').addEventListener('click', () => {
                    this.addNewTodo();
                });
            }
            
            setActiveTab(day) {
                document.querySelectorAll('.day-tab').forEach(tab => {
                    tab.classList.remove('active');
                    if (tab.dataset.day === day) {
                        tab.classList.add('active');
                    }
                });
            }
            
            loadTodos(day) {
                try {
                    this.todos = getTodosForDay(day);
                    this.renderTodos();
                } catch (error) {
                    console.error('Error loading todos:', error);
                }
            }
            
            renderTodos() {
                const todoList = document.getElementById('todo-list');
                const noItems = document.getElementById('no-items');
                
                if (this.todos.length === 0) {
                    todoList.innerHTML = '';
                    noItems.style.display = 'block';
                    return;
                }
                
                noItems.style.display = 'none';
                
                // Separate completed and active todos
                const activeTodos = this.todos.filter(todo => !todo.completed);
                const completedTodos = this.todos.filter(todo => todo.completed);
                
                // Render active todos first, then completed
                const allTodos = [...activeTodos, ...completedTodos];
                
                todoList.innerHTML = allTodos.map(todo => this.createTodoElement(todo)).join('');
                
                // Add event listeners to new elements
                this.addTodoEventListeners();
            }
            
            createTodoElement(todo) {
                const completedClass = todo.completed ? 'completed' : '';
                const completedChecked = todo.completed ? 'checked' : '';
                
                return `
                    <div class="todo-item ${completedClass}" data-id="${todo.id}">
                        <div class="todo-content">
                            <input type="checkbox" class="todo-checkbox" ${completedChecked}>
                            <span class="todo-text" contenteditable="false">${todo.text}</span>
                        </div>
                        <div class="todo-actions">
                            <button class="todo-edit-btn">‚úèÔ∏è</button>
                            <button class="todo-delete-btn">üóëÔ∏è</button>
                        </div>
                    </div>
                `;
            }
            
            addTodoEventListeners() {
                // Checkbox events
                document.querySelectorAll('.todo-checkbox').forEach(checkbox => {
                    checkbox.addEventListener('change', (e) => {
                        const todoItem = e.target.closest('.todo-item');
                        const todoId = todoItem.dataset.id;
                        const completed = e.target.checked;
                        this.toggleTodo(todoId, completed);
                    });
                });
                
                // Edit button events
                document.querySelectorAll('.todo-edit-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        const todoItem = e.target.closest('.todo-item');
                        const todoId = todoItem.dataset.id;
                        this.startEditing(todoId);
                    });
                });
                
                // Delete button events
                document.querySelectorAll('.todo-delete-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        const todoItem = e.target.closest('.todo-item');
                        const todoId = todoItem.dataset.id;
                        this.deleteTodo(todoId);
                    });
                });
                
                // Text click events for editing
                document.querySelectorAll('.todo-text').forEach(text => {
                    text.addEventListener('click', (e) => {
                        if (this.editingId === null) {
                            const todoItem = e.target.closest('.todo-item');
                            const todoId = todoItem.dataset.id;
                            this.startEditing(todoId);
                        }
                    });
                });
            }
            
            async addNewTodo() {
                const text = prompt('Enter your new todo:');
                if (!text || text.trim() === '') return;
                
                try {
                    const newTodo = addTodo(text.trim(), this.currentDay);
                    this.todos.push(newTodo);
                    this.renderTodos();
                } catch (error) {
                    console.error('Error adding todo:', error);
                }
            }
            
            async toggleTodo(todoId, completed) {
                try {
                    const updatedTodo = updateTodo(todoId, { completed: !!completed });
                    if (updatedTodo) {
                        const index = this.todos.findIndex(t => String(t.id) === String(todoId));
                        if (index !== -1) {
                            this.todos[index] = updatedTodo;
                        }
                        // Re-render to re-order
                        this.loadTodos(this.currentDay);
                    }
                } catch (error) {
                    console.error('Error updating todo:', error);
                }
            }
            
            startEditing(todoId) {
                if (this.editingId !== null) {
                    this.finishEditing();
                }
                
                this.editingId = todoId;
                const todoItem = document.querySelector(`[data-id="${todoId}"]`);
                const textElement = todoItem.querySelector('.todo-text');
                
                textElement.contentEditable = true;
                textElement.focus();
                textElement.classList.add('editing');
                
                // Select all text
                const range = document.createRange();
                range.selectNodeContents(textElement);
                const selection = window.getSelection();
                selection.removeAllRanges();
                selection.addRange(range);
                
                // Add event listeners for finishing edit
                textElement.addEventListener('blur', () => this.finishEditing(), { once: true });
                textElement.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        this.finishEditing();
                    } else if (e.key === 'Escape') {
                        e.preventDefault();
                        this.cancelEditing();
                    }
                });
            }
            
            async finishEditing() {
                if (this.editingId === null) return;
                
                const todoItem = document.querySelector(`[data-id="${this.editingId}"]`);
                const textElement = todoItem.querySelector('.todo-text');
                const newText = textElement.textContent.trim();
                
                if (newText === '') {
                    this.cancelEditing();
                    return;
                }
                
                try {
                    const updatedTodo = updateTodo(this.editingId, { text: newText });
                    if (updatedTodo) {
                        const index = this.todos.findIndex(t => String(t.id) === String(this.editingId));
                        if (index !== -1) {
                            this.todos[index] = updatedTodo;
                        }
                    }
                } catch (error) {
                    console.error('Error updating todo:', error);
                }
                
                this.editingId = null;
                this.renderTodos();
            }
            
            cancelEditing() {
                if (this.editingId === null) return;
                
                this.editingId = null;
                this.renderTodos();
            }
            
            async deleteTodo(todoId) {
                if (!confirm('Are you sure you want to delete this todo?')) return;
                
                try {
                    const result = softDeleteTodo(todoId);
                    if (result) {
                        this.todos = this.todos.filter(t => String(t.id) !== String(todoId));
                        this.renderTodos();
                    }
                } catch (error) {
                    console.error('Error deleting todo:', error);
                }
            }
        }
        
        // Initialize todo app
        const todoApp = new TodoApp();
        
        // Images are sourced from per-category manifest.json files created by the generator script

        // Dynamic category discovery (HTTP only). Falls back to static mapping when unavailable
        const categoryImageCache = {};
        const isHttpContext = location.protocol === 'http:' || location.protocol === 'https:';

        async function listCategoryImages(category) {
            if (!isHttpContext) return [];
            if (categoryImageCache[category]) return categoryImageCache[category];

            const base = `./img/${category}/`;
            // 1) Try manifest.json if present
            try {
                const manifestRes = await fetch(base + 'manifest.json', { cache: 'no-cache' });
                if (manifestRes.ok) {
                    const files = await manifestRes.json();
                    if (Array.isArray(files)) {
                        const normalized = files
                            .filter(name => typeof name === 'string')
                            .filter(name => /\.(jpe?g|png|gif|webp)$/i.test(name))
                            .map(name => base + name);
                        categoryImageCache[category] = normalized;
                        return normalized;
                    }
                }
            } catch (_) { /* ignore */ }

            // 2) Try directory listing (works on some static servers like python http.server)
            try {
                const dirRes = await fetch(base, { cache: 'no-cache' });
                if (dirRes.ok) {
                    const html = await dirRes.text();
                    // Parse links from listing
                    const container = document.createElement('div');
                    container.innerHTML = html;
                    const links = Array.from(container.querySelectorAll('a'))
                        .map(a => a.getAttribute('href'))
                        .filter(Boolean)
                        .filter(href => /\.(jpe?g|png|gif|webp)$/i.test(href))
                        .map(href => base + href.replace(/^\/?/, ''));
                    if (links.length > 0) {
                        categoryImageCache[category] = links;
                        return links;
                    }
                }
            } catch (_) { /* ignore */ }

            // 3) If nothing else worked, return empty list
            categoryImageCache[category] = [];
            return [];
        }

        async function resolveImageForItemAsync(item) {
            if (!item.category) return item.image || null;
            const files = await listCategoryImages(item.category);
            if (files.length === 0) return null;
            return files[Math.floor(Math.random() * files.length)];
        }

        // Default metadata for known categories (used when generating dynamically)
        const DEFAULT_CAROUSEL_METADATA = {
            plants: {
                title: 'Care for your babies',
                description: 'Water your plants. Check on their new leaves. Give them a little mist. Connect with nature, even indoors!'
            },
            reading: {
                title: 'Dive into a Chapter',
                description: 'Read a chapter of that book you\'re currently enjoying (or start a new one!). Let your imagination wander.'
            },
            tea: {
                title: 'Ritual of Warmth',
                description: 'Make yourself a cup of tea. Or coffee. Enjoy the process of waiting and be mindful.'
            },
            journaling: {
                title: 'Quiet Reflection',
                description: 'Grab the iPad. Write for 5 minutes about what\'s on your mind, draw something you think would be cute.'
            },
            exercise: {
                title: 'Move Your Body',
                description: 'Do 10 minutes of light exercise or stretching. Get that blood flowing and release some tension.'
            },
            cleaning: {
                title: 'Mini-Clean Up',
                description: 'Tidy one small area: clear your desk, wipe down the kitchen counter, or organize a drawer. A little progress goes a long way.'
            },
            cats: {
                title: 'Feline Therapy',
                description: 'Spend 5-10 minutes playing with your cats. Their purrs are a powerful antidote to stress.'
            },
            hydration: {
                title: 'Hydrate & Refresh',
                description: 'Grab a large glass of water. Sometimes a simple physical need is disguised as emotional hunger.'
            },
            projects: {
                title: 'Nourish Creativity',
                description: 'Work on one of your small projects for 15 minutes. Even a tiny step forward can feel incredibly rewarding.'
            }
        };

        function toTitleCase(word) {
            return String(word || '')
                .replace(/[-_]/g, ' ')
                .replace(/\b\w/g, (m) => m.toUpperCase());
        }

        function makeCarouselItem(category) {
            const meta = DEFAULT_CAROUSEL_METADATA[category] || {};
            return {
                category,
                title: meta.title || toTitleCase(category),
                description: meta.description || 'Do a small, mindful action in this category to refocus your energy.'
            };
        }

        let carouselData = [];

        async function loadCarouselData() {
            if (isHttpContext) {
                try {
                    const res = await fetch('./img/manifest.json', { cache: 'no-cache' });
                    if (res.ok) {
                        const categories = await res.json();
                        if (Array.isArray(categories) && categories.length > 0) {
                            return categories
                                .filter((name) => typeof name === 'string')
                                .map((name) => makeCarouselItem(name));
                        }
                    }
                } catch (_) { /* ignore */ }
            }

            // Fallback to known defaults when manifest is unavailable
            return Object.keys(DEFAULT_CAROUSEL_METADATA).map((name) => ({
                category: name,
                title: DEFAULT_CAROUSEL_METADATA[name].title,
                description: DEFAULT_CAROUSEL_METADATA[name].description
            }));
        }

        let currentIndex = 0;
        const track = document.getElementById('carousel-track');
        const currentNum = document.getElementById('current-num');
        const totalNum = document.getElementById('total-num');
        let slides = [];

        async function createSlides() {
            track.innerHTML = '';
            carouselData.forEach((item, index) => {
                const slide = document.createElement('div');
                slide.className = 'carousel-slide';
                // Resolve asynchronously from manifest and pick a random image per category
                resolveImageForItemAsync(item).then((url) => {
                    if (url) slide.style.backgroundImage = `url('${url}')`;
                });
                slide.innerHTML = `
                    <h3>${item.title}</h3>
                    <p>${item.description}</p>
                `;
                
                // Add click handler for navigation
                slide.addEventListener('click', () => {
                    if (index === getPrevIndex()) {
                        goToPrev();
                    } else if (index === getNextIndex()) {
                        goToNext();
                    }
                });
                
                track.appendChild(slide);
                slides.push(slide);
            });
        }

        function getPrevIndex() {
            return (currentIndex - 1 + carouselData.length) % carouselData.length;
        }

        function getNextIndex() {
            return (currentIndex + 1) % carouselData.length;
        }

        function updateSlides() {
            const prevIndex = getPrevIndex();
            const nextIndex = getNextIndex();
            
            slides.forEach((slide, index) => {
                slide.classList.remove('active', 'prev', 'next', 'hidden');
                
                if (index === currentIndex) {
                    slide.classList.add('active');
                    slide.style.setProperty('--slide-x', '0');
                    slide.style.setProperty('--slide-scale', '1');
                } else if (index === prevIndex) {
                    slide.classList.add('prev');
                    slide.style.setProperty('--slide-x', '-320px');
                    slide.style.setProperty('--slide-scale', '0.8');
                } else if (index === nextIndex) {
                    slide.classList.add('next');
                    slide.style.setProperty('--slide-x', '320px');
                    slide.style.setProperty('--slide-scale', '0.8');
                } else {
                    slide.classList.add('hidden');
                }
            });
            
            currentNum.textContent = currentIndex + 1;
        }

        function goToPrev() {
            currentIndex = getPrevIndex();
            updateSlides();
        }

        function goToNext() {
            currentIndex = getNextIndex();
            updateSlides();
        }

        // Keyboard navigation
        document.addEventListener('keydown', (e) => {
            if (e.key === 'ArrowLeft') goToPrev();
            if (e.key === 'ArrowRight') goToNext();
        });

        // Initialize
        (async () => {
            try {
                carouselData = await loadCarouselData();
                if (!Array.isArray(carouselData) || carouselData.length === 0) {
                    carouselData = [];
                }
                totalNum.textContent = carouselData.length;
                currentIndex = carouselData.length > 0 ? Math.floor(Math.random() * carouselData.length) : 0;
                await createSlides();
                updateSlides();
            } catch (err) {
                console.error('Failed to initialize carousel', err);
            }
        })();
    </script>
</body>
</html>